<!DOCTYPE html>
<html lang="lv"> 
<!--SEO optimization jept-->
<head>
<meta charset="UTF-8">
<link rel="stylesheet" href="style.css">
<title>OSK: Dinamiskā atmiņas iedalīšana</title>

	<script src="inc/jquery.js"></script>
	<script src="inc/raphael.js"></script>
	<script src="inc/draw.js"></script>
	<script src="inc/input.js"></script>
<script> function show(aval) {
    if (aval == "FF") {
    hiddenDiv.style.display='inline-block';
    hiddenDivN.style.display='none';
    hiddenDivB.style.display='none';
    hiddenDivW.style.display='none';
    Form.fileURL.focus();
    } 
    else if (aval == "BF") {
    hiddenDivB.style.display='inline-block';
    hiddenDiv.style.display='none';
    hiddenDivN.style.display='none';
    hiddenDivW.style.display='none';
    Form.fileURL.focus();
    } 
    else if (aval == "NF") {
    hiddenDivN.style.display='inline-block';
    hiddenDiv.style.display='none';
    hiddenDivB.style.display='none';
    hiddenDivW.style.display='none';
    Form.fileURL.focus();
    } 
    else if (aval == "WF") {
    hiddenDivW.style.display='inline-block';
    hiddenDiv.style.display='none';
    hiddenDivB.style.display='none';
    hiddenDivN.style.display='none';
    Form.fileURL.focus();
    } 
    else{
    hiddenDiv.style.display='none';
    }
  }</script>
</head>
<body>
	<h1>DINAMISKĀ ATMIŅAS IEDALĪŠANA</h1>
	<h2>Dynamic memory allocation</h2>
<div class="row">       
           <fieldset>
          <label>Pick an algorithm:</label>
                <select name="Algorithm" onchange="java_script_:show(this.options[this.selectedIndex].value)">
                  <option value="FF">First-fit</option>
                  <option value="BF">Best-fit</option>
                  <option value="NF">Next-fit</option>
                  <option value="WF">Worst-fit</option>
              </select>

              <div id="hiddenDiv" style="display:none">
                  <p>In the first fit approach is to allocate the first free partition or hole large enough which can accommodate the process. It finishes after finding the first suitable free partition.
                  </p>
              </div>
              <div id="hiddenDivB" style="display:none">
                  <p>The best fit deals with allocating the smallest free partition which meets the requirement of the requesting process. This algorithm first searches the entire list of free partitions and considers the smallest hole that is adequate. It then tries to find a hole which is close to actual process size needed.
                  </p>
              </div>
              <div id="hiddenDivN" style="display:none">
                  <p>Next fit is a modified version of first fit. It begins as first fit to find a free partition. When called next time it starts searching from where it left off, not from the beginning.
                  </p>
              </div>
              <div id="hiddenDivW" style="display:none">
                  <p>In worst fit approach is to locate largest available free portion so that the portion left will be big enough to be useful. It is the reverse of best fit.
	</p>
              </div>
           </fieldset>
</div>	
        
        
	<div id="about">		
			<p class="t">Projekta autori:</p>
               <p class="a"> Anastasija Ņikiforova (an13028)</p>
               <p class="a"> Dmitrijs Grekovs (dg13026)</p>
               <p class="a"> Vitālijs Feščenko (vf13004)</p>
               <br><br>
               <p class="p"> <b>Projekta mērķis: </b> <br>parādīt kā notiek atmiņas iedalīšana, kādi ir atmiņas iedalīšanas visizplatītākie algoritmi un ar ko tie atšķiras savā starpā. </p>
	</div>
	Canvas was here

<hr>
</body>
<footer> © 2017 - Anastasija Ņikiforova, Dmitrijs Grekovs, Vitālijs Feščenko </footer>

<script src="memory.js"></script>
<script>

// Inits memory, first argument is memory size, second argument is info size per block
// init() can be reused, deleting existing blocks
memory.init(1024,5);

memory.nextFit(10);	// bs.take -> find block and set to status taken / bs.free -> find block and set status to free
memory.nextFit(159);
memory.nextFit(13);
memory.nextFit(3);
memory.nextFit(200);
memory.nextFit(4);
memory.nextFit(173);
/*
memory.cleanBlocks();	// Sets all blocks to free - doesn't affect fragmentation
memory.takeBlocks();	// Sets all blocks to allocated - doesn't affect fragmentation

// Deletes all blocks and performs random fragmentation on total size defined

// First argument - amount of blocks memory will be fragmented (biggest priority - function always return specified number of blocks even if it doesn't fit deviation and free memory percentage arguments)
// Second argument - deviation between size of blocks (small - all blocks equal, large - more diverse)
// Third argument - percent of memory to be left free (not the best solution, best would be (O(n!). Also the more blocks and deviation, the better resulting percent fits desired)
memory.randomFragmentation(20 ,50, 25);
*/
console.log(memory.getStatistics());

console.log(memory.getBlocks());


</script>
</html>
