<!DOCTYPE html>
<html lang="lv"> 
<!--SEO optimization jept-->
<head>
<meta charset="UTF-8">
<link rel="stylesheet" href="style.css">
<title>OSK: Dinamiskā atmiņas iedalīšana</title>
<script src="inc/jquery.js"></script>
<script src="inc/raphael.js"></script>
<script src="inc/draw.js"></script>
<script src="inc/input.js"></script>

<script> function show(aval) {
    if (aval == "FF") {
    hiddenDiv.style.display='inline-block';
    hiddenDivN.style.display='none';
    hiddenDivB.style.display='none';
    hiddenDivW.style.display='none';
    Form.fileURL.focus();
    } 
    else if (aval == "BF") {
    hiddenDivB.style.display='inline-block';
    hiddenDiv.style.display='none';
    hiddenDivN.style.display='none';
    hiddenDivW.style.display='none';
    Form.fileURL.focus();
    } 
    else if (aval == "NF") {
    hiddenDivN.style.display='inline-block';
    hiddenDiv.style.display='none';
    hiddenDivB.style.display='none';
    hiddenDivW.style.display='none';
    Form.fileURL.focus();
    } 
    else if (aval == "WF") {
    hiddenDivW.style.display='inline-block';
    hiddenDiv.style.display='none';
    hiddenDivB.style.display='none';
    hiddenDivN.style.display='none';
    Form.fileURL.focus();
    } 
    else{
    hiddenDiv.style.display='none';
    }
  }
  </script>

<script>
function myFunction1() {
    var x = document.getElementById("Processes").value;
    document.getElementById("demo3").innerHTML = x;
}
</script>

</head>
<body>
	<h1>DINAMISKĀ ATMIŅAS IEDALĪŠANA</h1>
	<h2>Dynamic memory allocation</h2>
                       <p id="demo" style="color:red; font-weight: bold">TEST: fields and buttons just get data and return it; 1) Buttons onclick should be changed according to functionality; 2) myFunction() - for "Fragment" button; 3) myFunction1() - for "Animation" button</p>

<div class="row">       
           <fieldset>
               Statistics:<br>
	<canvas id="pie_chart" width="310" height="140" style="border:2px solid rgb(193, 39, 45)"></canvas>

	<hr>
               <form id="myForm">
               <label>Memory Buffer:</label>
               <input type="number" name="buff_size" value="1024" id="buff_size" min="0" placeholder="Memory buffer"> <br>
               
               <label>Information size per block:</label>
               <input type="number" name="inf_size" value="5" id="info_size" min="0" placeholder="Info size"> <br>
              
               <button onclick="init_memory()" class="button button1">Init memory</button><br>
               
               
               <label>Number of blocks: </label>
               <input type="number" name="block_number" value="5" id="block_number" min="1"><br>
                               
               <label>Standard deviation:</label>
               <input type="number" name="stdev" value="10" id="stdev" min="0"><br>
                              
               <label>Unallocated memory:</label>
               <input type="number" name="mem_free" value="25" id="mem_free" min="0" max="100"> %<br>
               
               <button onclick="fragment_memory()" class="button button1">Fragment memory</button><br>
                <hr>
               <button onclick="allocate_memory()" class="button button4">Allocate all blocks</button>
              
               <button onclick="deallocate_memory()" class="button button4">Deallocate all blocks</button>
               <br>
               
           <label>Pick an algorithm:</label>
                <select id="Algorithm" name="Algorithm" onchange="java_script_:show(this.options[this.selectedIndex].value)">
                  <option value="" disabled selected>Algorithm</option>
                  <option value="FF">First-fit</option>
                  <option value="BF">Best-fit</option>
                  <option value="NF">Next-fit</option>
                  <option value="WF">Worst-fit</option>
              </select>
              
              <div id="hiddenDiv" style="display:none">
                  <p>In the first fit approach is to allocate the first free partition or hole large enough which can accommodate the process. It finishes after finding the first suitable free partition.
                  </p>
              </div>
              <div id="hiddenDivB" style="display:none">
                  <p>The best fit deals with allocating the smallest free partition which meets the requirement of the requesting process. This algorithm first searches the entire list of free partitions and considers the smallest hole that is adequate. It then tries to find a hole which is close to actual process size needed.
                  </p>
              </div>
              <div id="hiddenDivN" style="display:none">
                  <p>Next fit is a modified version of first fit. It begins as first fit to find a free partition. When called next time it starts searching from where it left off, not from the beginning.
                  </p>
              </div>
              <div id="hiddenDivW" style="display:none">
                  <p>In worst fit approach is to locate largest available free portion so that the portion left will be big enough to be useful. It is the reverse of best fit.
	</p>
              </div>
           <br>
           <label>Processes:</label>
               <input type="text" id="Processes" placeholder="Size of processes">
               <p id="demo3"></p>
                
               
               
               <button onclick="myFunction1()" class="button button2">Animation</button>
               <button type="reset" value="Reset" class="button button3">Reset</button>

</form>
           </fieldset>
</div>	
              <canvas id="myCanvas" width="600" height="400" style="border:0px solid black;">
Your browser does not support the HTML5 canvas tag.
</canvas>
        
	<div id="about">		
			<p class="t">Projekta autori:</p>
               <p class="a"> Anastasija Ņikiforova (an13028)</p>
               <p class="a"> Dmitrijs Grekovs (dg13026)</p>
               <p class="a"> Vitālijs Feščenko (vf13004)</p>
               <br><br>
               <p class="p"> <b>Projekta mērķis: </b> <br>parādīt kā notiek atmiņas iedalīšana, kādi ir atmiņas iedalīšanas visizplatītākie algoritmi un ar ko tie atšķiras savā starpā. </p>
	</div>
	Canvas was here

<hr>
<div class = "footer"> © 2017 - Anastasija Ņikiforova, Dmitrijs Grekovs, Vitālijs Feščenko </div>
</body>

<script src="memory.js"></script>
<script>

allocate_memory = function() {
	memory.takeBlocks();
	ctx.drawChart();
}

deallocate_memory = function() {
	memory.cleanBlocks();
	ctx.drawChart();
}

init_memory = function() {
	var buff = Number(document.getElementById("buff_size").value);
	var info = Number(document.getElementById("info_size").value);
	memory.init(buff,info);
	ctx.drawChart();
	console.log(memory.getStatistics());
	console.log(memory.getBlocks());
}

fragment_memory = function() {
	var block_number = Number(document.getElementById("block_number").value);
	var stdev = Number(document.getElementById("stdev").value);
	var mem_free = Number(document.getElementById("mem_free").value);
	memory.randomFragmentation(block_number, stdev, mem_free);
	ctx.drawChart();
	console.log(memory.getStatistics());
	console.log(memory.getBlocks());
}

// Inits memory, first argument is memory size, second argument is info size per block
// init() can be reused, deleting existing blocks
memory.init(1024,5);

memory.nextFit(10);	// bs.take -> find block and set to status taken / bs.free -> find block and set status to free
memory.nextFit(159);
memory.nextFit(13);
memory.nextFit(3);
memory.nextFit(200);
memory.nextFit(4);
memory.nextFit(173);

memory.cleanBlocks();	// Sets all blocks to free - doesn't affect fragmentation
memory.takeBlocks();	// Sets all blocks to allocated - doesn't affect fragmentation

// Deletes all blocks and performs random fragmentation on total size defined

// First argument - amount of blocks memory will be fragmented (biggest priority - function always return specified number of blocks even if it doesn't fit deviation and free memory percentage arguments)
// Second argument - deviation between size of blocks (small - all blocks equal, large - more diverse)
// Third argument - percent of memory to be left free (not the best solution, best would be (O(n!). Also the more blocks and deviation, the better resulting percent fits desired)
memory.randomFragmentation(20 ,50, 25);

console.log(memory.getStatistics());

console.log(memory.getBlocks());

</script>
<script src="chart.js"></script>
</html>
